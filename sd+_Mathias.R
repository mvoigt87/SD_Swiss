##### Exploring the relationship between the modal age at deaths and the standard deviation above it #####
##### ---------------------------------------------------------------------------------------------- #####

## Following Cheung et al (2009), the goal of this project is to investigate the characteristics of the 
## longevity development in Switzerland. We assume that the increase in life expectancy which went along with
## the compression around the modal age of death (decreasing standard deviation) is increasingly driven by the
## shift of the modal age at death to higher ages. Looking at the variability measures could proof that hypothesis


# 0.1 load packages
library(HMDHFDplus)
library(MortalitySmooth)
library(MortHump)
library(tidyverse)
# library(LifeTables)

# 0.2 working directory
setwd("C:/Users/Mathias/Documents/LongPop_Madrid/Secondment/Geneva/Compression of Mortality/Data and Code")

# 0.3 set passworts for HMDHFDplus
name.m <- "mathias.voigt4@uni-rostock.de"
name.f <- "m.voigt87@gmx.de"
pw.m <- "1320270854"
pw.f <- "43700"

### For Males!

females <- readHMDweb(CNTRY = "CHE", item = "fltper_1x1", username = name.m, password = pw.m)

# Smooth the mortality surface with P-Splines
fit <- Mort2Dsmooth(x = unique(females$Age), y = unique(females$Year), Z = matrix(females$mx, nrow = 111), 
                    method = 3, lambdas = c(.01,.01))
# plots
plot(fit)

# use the predict function
females$mxs <- as.vector(predict(fit, type = "response"))

lt <- by(data = females$mxs, INDICES = females$Year, FUN = function(x){LT(Mx = x, mxsmooth = FALSE, 
                                                                          axsmooth = FALSE)})
## Compare the estimated values with observed
females$dxs <- unlist(lapply(lt, function(x){x$dx}))
females$exs <- unlist(lapply(lt, function(x){x$ex}))

plot(females$ex, females$exs)
head(females)

#femalesplus <- data.frame(Year = rep(unique(females$Year), each = 1100), x = rep(seq(0,109.9,0.1),length(unique(females$Year))))
#femalesplus$dxs <- predict(fit, newdata = data.frame(y = femalesplus$Year, x = femalesplus$x), type = "response")


### For Males
### ---------

males <- readHMDweb(CNTRY = "CHE", item = "mltper_1x1", username = name.m, password = pw.m)
# Smooth the mortality surface with P-Splines
fit <- Mort2Dsmooth(x = unique(males$Age), y = unique(males$Year), Z = matrix(males$mx, nrow = 111), 
                    method = 3, lambdas = c(.01,.01))
plot(fit) # Spanish flu visible
# extract smoothed life table mx and calculate the rest of the indicators
males$mxs <- as.vector(predict(fit, type = "response"))
lt <- by(data = males$mxs, INDICES = males$Year, FUN = function(x){LT(Mx = x, mxsmooth = FALSE, axsmooth = FALSE)})
males$dxs <- unlist(lapply(lt, function(x){x$dx}))
males$exs <- unlist(lapply(lt, function(x){x$ex}))
plot(males$ex, males$exs)
head(males)

## test if outliers were generated by the Spanish flu (year 1918)

males.without <- males %>% filter(Year!=1918)
par(mfrow=c(1,2))
plot(males$ex, males$exs)
plot(males.without$ex, males.without$exs)
par(mfrow=c(1,1))

# looks like

# functions to compute e-dagger and sd+ (check this one though!)

# e-dagger - the average life expectancy losses due to death. 

# edagger <- function(lt){
#   
#   ed <- sum(lt$dxs / sum(lt$dxs) * lt$exs)
#   
#   return(ed)
#   
# }

# sdplus <- function(lt){
#   
#   dx <- lt$dxs / sum(lt$dxs)
#   x <- lt$Age
#   m <- which.max(dx[x > 50]) + 51
#   dx <- dx[m:length(dx)]
#   x  <-  x[m:length(x)]
#   mean <- sum(x * dx) / sum(dx)
#   s <- sqrt(sum((x - m)^2 * dx) / sum(dx))
#   
#   return(s)
#   
# }
# 
# # apply both functions
# png("EPC/edagger.png", width = 30, height = 15, units = "cm", res = 600)
# par(mfrow = c(1,2), mar = c(3,4,3,1) + 0.1)
# plot(unique(females$Year), as.vector(by(data = females, INDICES = females$Year, FUN = edagger)), type = "l", xlab = "", ylab = expression(e^dagger), las = 1, main = "Swiss females", ylim = c(5,25))
# plot(unique(males$Year), as.vector(by(data = males, INDICES = males$Year, FUN = edagger)), type = "l", xlab = "", ylab = expression(e^dagger), las = 1, main = "Swiss males", ylim = c(5, 25))
# par(mfrow = c(1,1), mar = c(5,4,4,1) + 0.1)
# dev.off()
# 
# plot(unique(females$Year), as.vector(by(data = females, INDICES = females$Year, FUN = sdplus)), type = "l")


### ----------------- Experimenting

#######################################################
### Standard deviation (Tuljarpurka & Edwards 2005) ###
#######################################################

# dx matrix - females
dx.fem <- tapply(X=females$dxs,
                 INDEX=list(Age=females$Age,
                            Year=females$Year),
                 FUN=sum)

# ex matrix - females
# dx matrix - females
ex.fem <- tapply(X=females$exs,
                 INDEX=list(Age=females$Age,
                            Year=females$Year),
                 FUN=sum)

# To avoid the noise generated by infant mortality = suggested to start at age 10
 # Note: Margin=2 in matrix stands for columns

sd10.fem <- apply(X=dx.fem[-(1:11),], MARGIN = 2, FUN = function(x)
                  sd(c(x))) 
summary(sd10.fem) 
plot(sd10.fem)

# from age 0
sd.fem <- apply(X=dx.fem, MARGIN = 2, FUN = function(x)
                sd(c(x))) 
plot(sd.fem) 

###########
### IQR ###
###########
IQR.fem <- apply(X=dx.fem, MARGIN = 2, FUN = function(x)
                  IQR(x))
summary(IQR.fem)
plot(IQR.fem)

################
### e-Dagger ###
################

# needs to be applied to the life table
# formula based on: http://pages.stern.nyu.edu/~dbackus/BCH/demography/ZhangVaupel_ageseparating_DR_09.pdf
# and: www.demogr.mpg.de/papers/technicalreports/tr-2012-002.pdf

e.dagger.fun <- function(lt) {
  len <- nrow(lt)
  ea <- ((lt$Tx + c(lt$Tx[-1],0))/2) / (lt$Lx)
  da <- lt$dxs/sum(lt$dxs)
  e.dagger <- sum(da * ea)
  return(e.dagger)
}

e.dagger.fun(subset(females,Year==2010))

# 
# test <- sapply(X=females,FUN = e.dagger.fun)
# 
# e.d.fem <- as.data.frame(unique(females$Year))
# e.d.fem <- e.d.fem %>% mutate()
# 
# for (i in 1876:2014) {
#   e.d.fem$edagger[e.d.fem$Year==1] <- c(e.dagger.fun(subset(females,Year==i)))
#                }

#######################
### Keyfitz entropy ###
#######################
# H <- e.dagger.fun()/exs
# H

# sum(dxs(x)*0.5*(exs(x)+exs(x+1)))
